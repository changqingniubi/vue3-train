{"version":3,"file":"runtime-dom.cjs.js","sources":["../../shared/src/index.ts","../../runtime-core/src/createVNode.ts","../../runtime-core/src/apiCreateApp.ts","../../reactivity/src/effect.ts","../../reactivity/src/reactive.ts","../../reactivity/src/computed.ts","../../reactivity/src/ref.ts","../../runtime-core/src/index.ts","../src/nodeOps.ts","../src/patchProp.ts","../src/index.ts"],"sourcesContent":["/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-15 17:55:45\n * @LastEditTime: 2021-12-18 21:15:17\n * @LastEditors: changqing\n * @Usage: \n */\nexport function isObject(value: unknown): boolean {\n  return typeof value === 'object' && value !== null\n}\nexport function isFunction(value):boolean{\n  return typeof value === 'function'\n}\n\nexport function isString(value) {\n  return typeof value === 'string'\n}\n\nexport const enum ShapeFlags {\n  ELEMENT = 1, // 元素\n  FUNCTIONAL_COMPONENT = 1 << 1, // 函数式组件\n  STATEFUL_COMPONENT = 1 << 2, // 普通组件\n  TEXT_CHILDREN = 1 << 3, // 孩子是文本\n  ARRAY_CHILDREN = 1 << 4, // 孩子是数组\n  SLOTS_CHILDREN = 1 << 5, // 组件插槽\n  TELEPORT = 1 << 6, // teleport组件\n  SUSPENSE = 1 << 7, // suspense组件\n  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT \t// 组件\n}\n/*\nlet r = ShapeFlags.ELEMENT | ShapeFlags.FUNCTIONAL_COMPONENT; // r包含元素和函数式组件\n// 我们像看r 是不是元素\n(r & ShapeFlags.ELEMENT) > 0; // 说明包含元素\n(r & ShapeFlags.FUNCTIONAL_COMPONENT) > 0\n*/\n\n\n  // 二进制  00000100  位移  | & 是做权限必备的一个操作 \n  // | 来组合权限 & 来判断是否包含某个权限\n  //   001 |  010 => 011  =3    011 & 001 = 001   011 & 010 => 010   011 & 100  -> 000\n  // 001\n  // 010\n  // 100","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 22:17:44\n * @LastEditTime: 2021-12-18 22:31:54\n * @LastEditors: changqing\n * @Usage: \n */\nimport { isObject, isString, ShapeFlags } from \"@vue/shared\";\nexport function createVNode(type, props, children = null) { // h('div',{},['helloworld','helloworld'])\n    // 虚拟节点就是 用一个对象来描述信息的  \n\n    // & | \n    const shapeFlag = isObject(type) ?\n        ShapeFlags.COMPONENT :\n        isString(type) ?\n            ShapeFlags.ELEMENT :\n            0\n\n    const vnode = { // 跨平台\n        __v_isVNode: true,\n        type,\n        shapeFlag,\n        props,\n        children,\n        key: props && props.key, // key值\n        component: null, // 如果是组件的虚拟节点要保存组件的实例\n        el: null, // 虚拟节点对应的真实节点\n    }\n    if(children){\n      \n        // 告诉此节点 是什么样的儿子 \n        // 稍后渲染虚拟节点的时候 可以判断儿子是数组 就循环渲染\n        vnode.shapeFlag =  vnode.shapeFlag | (isString(children) ? ShapeFlags.TEXT_CHILDREN:ShapeFlags.ARRAY_CHILDREN)\n    }\n    // vnode 就可以描述出来 当前他是一个什么样的节点 儿子是什么样的\n    return vnode; // createApp(App)\n}","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 22:14:02\n * @LastEditTime: 2021-12-18 22:14:02\n * @LastEditors: changqing\n * @Usage: \n */\nimport { createVNode } from \"./createVNode\";\n\nexport function createAppAPI(render) {\n    return (rootComponent, rootProps) => {\n        let isMounted = false;\n        const app = {\n            mount(container) {\n                // 1.创造组件虚拟节点 \n                let vnode = createVNode(rootComponent, rootProps); // h函数\n                // 2.挂载的核心就是根据传入的组件对象 创造一个组件的虚拟节点 ，在将这个虚拟节点渲染到容器中\n                render(vnode, container)\n                if (!isMounted) {\n                    isMounted = true;\n                }\n            }\n        }\n        return app\n    }\n}\n","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 15:34:57\n * @LastEditTime: 2021-12-18 16:09:05\n * @LastEditors: changqing\n * @Usage: \n */\n\n// effect1(()=>{\n//     state.name\n//     effect2(()=>{\n//         state.age;\n//     })\n//     state.address\n// })\n// effectStack = [effect1] activeEffect = effect1\n// effect1 -> name\n// effectStack = [effect1，effect2] activeEffect = effect2\n// effect2 -> age\n// effectStack = [effect1] activeEffect = effect1\n// effect1 -> address\n\n\nlet effectStack = []; // 目的就是为了能保证我们effect执行的时候 可以存储正确的关系\nlet activeEffect;\n\n\nfunction cleanupEffect(effect) {\n  const { deps } = effect;\n  for (let dep of deps) {\n      // set 删除effect 让属性 删除掉对应的effect   name = []\n      dep.delete(effect); // 让属性对应的effect移除掉，这样属性更新的时候 就不会触发这个effect重新执行了\n  }\n}\n\n// 属性变化 触发的是 dep -> effect\n// effect.deps = [] 和属性是没关系的\nexport class ReactiveEffect {\n  active = true; // this.active = true;\n  deps = []; // 让effect 记录他依赖了哪些属性 ， 同时要记录当前属性依赖了哪个effect\n  constructor(public fn, public scheduler?) { // this.fn = fn;\n\n  }\n  run() { // 调用run的时候会让fn执行\n      if (!this.active) { // 稍后如果非激活状态 调用run方法 默认会执行fn函数\n          return this.fn();\n      }\n      if (!effectStack.includes(this)) { // 屏蔽同一个effect会多次执行\n          try {\n              effectStack.push(activeEffect = this);\n              return this.fn(); // 取值  new Proxy 会执行get方法  (依赖收集)\n          } finally {\n              effectStack.pop(); // 删除最后一个\n              activeEffect = effectStack[effectStack.length - 1]\n          }\n      }\n  }\n  stop() { // 让effect 和 dep 取消关联 dep上面存储的effect移除掉即可\n      if (this.active) {\n          cleanupEffect(this)\n          this.active = false;\n      }\n  }\n}\n// obj name :[effect]\n//     age : [effect]\n// {对象：{属性 ： [effect,effect]}  } \nexport function isTracking() {\n  return activeEffect !== undefined\n}\n\nconst targetMap = new WeakMap();\nexport function track(target, key) { // 一个属性对应多个effect， 一个effect中依赖了多个属性 =》 多对多\n  // 是只要取值我就要收集吗？不是\n  if (!isTracking()) { // 如果这个属性 不依赖于effect直接跳出即可\n      return\n  }\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map())); // {对象：map{}}\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n      depsMap.set(key, (dep = new Set()));// {对象：map{name:set[]}}\n  }\n  trackEffects(dep);\n}\nexport function trackEffects(dep) {\n  let shouldTrack = !dep.has(activeEffect); // 看一下这个属性有没有存过这个effect\n  if (shouldTrack) {\n      dep.add(activeEffect); // // {对象：map{name:set[effect,effect]}}\n      activeEffect.deps.push(dep); // 稍后用到\n  } // { 对象：{name:set,age:set}\n\n}\nexport function trigger(target, key) {\n  let depsMap = targetMap.get(target);\n  if (!depsMap) return;// 属性修改的属性 根本没有依赖任何的effect\n  let deps = []; // [set ,set ]\n  if (key !== undefined) {\n      deps.push(depsMap.get(key));\n  }\n  let effects = [];\n  for (const dep of deps) {\n      effects.push(...dep)\n  }\n  triggerEffects(effects);\n}\nexport function triggerEffects(dep) {\n  for (const effect of dep) { // 如果当前effect执行 和 要执行的effect是同一个，不要执行了 防止循环\n      if (effect !== activeEffect) {\n          if (effect.scheduler) {\n              return effect.scheduler()\n          }\n          effect.run(); // 执行effect\n      }\n  }\n}\nexport function effect(fn) {\n  const _effect = new ReactiveEffect(fn);\n  _effect.run(); // 会默认让fn执行一次\n  let runner = _effect.run.bind(_effect);\n  runner.effect = _effect; // 给runner添加一个effect实现 就是 effect实例\n  return runner;\n}\n// vue3 的响应式原理  取值时 收集对应的effect， 改值时找到对应的effect执行","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-17 11:07:14\n * @LastEditTime: 2021-12-18 16:16:05\n * @LastEditors: changqing\n * @Usage: \n */\nimport { isObject } from \"@vue/shared\";\nimport { track, trigger } from \"./effect\";\n\nconst enum ReactiveFlags{\n  IS_REACTIVE = '__v_isReactive'\n}\n\nconst mutableHandlers: ProxyHandler<Record<any, any>> = {\n  get(target, key, recevier) { // 代理对象的本身\n      if (key === ReactiveFlags.IS_REACTIVE) {\n          return true;\n      }\n      // 这里取值了， 可以收集他在哪个effect中\n      track(target,key);\n      const res = Reflect.get(target, key, recevier); // target[key]\n      return res;\n  },\n  set(target, key, value, recevier) {\n      let oldValue = (target as any)[key]\n      const res = Reflect.set(target, key, value, recevier); // target[key] = value\n       // 如果改变值了， 可以在这里触发effect更新\n      if(oldValue !== value){ // 值不发生变化 effect不需要重新执行\n        trigger(target,key); // 找属性对应的effect让她重新执行\n      }\n      return res;\n  }\n}\n// map和weakMap的区别\nconst reactiveMap = new WeakMap(); // weakmap 弱引用   key必须是对象，如果key没有被引用可以被自动销毁\n\nfunction createReactiveObject(target: object) { \n  // 先默认认为这个target已经是代理过的属性了\n  if ((target as any)[ReactiveFlags.IS_REACTIVE]) {\n      return target\n  }\n  // reactiveApi 只针对对象才可以 \n  if (!isObject(target)) {\n      return target\n  }\n  const exisitingProxy = reactiveMap.get(target); // 如果缓存中有 直接使用上次代理的结果\n  if (exisitingProxy) {\n      return exisitingProxy\n  }\n  const proxy = new Proxy(target, mutableHandlers); // 当用户获取属性 或者更改属性的时候 我能劫持到\n  reactiveMap.set(target, proxy); // 将原对象和生成的代理对象 做一个映射表\n\n  return proxy; // 返回代理\n}\n\nexport function reactive(target: object) {\n  return createReactiveObject(target)\n}\nexport function toReactive(value){\n  return isObject(value) ? reactive(value) : value\n}\n// readonly shallowReactive shallowReadnly \n// export function readonly(){\n// }\n// export function shallowReactive(){\n// }\n// export function shallowReadnly(){\n// }\n","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 16:19:54\n * @LastEditTime: 2021-12-18 16:19:54\n * @LastEditors: changqing\n * @Usage: \n */\nimport { isFunction } from \"@vue/shared\";\nimport { isTracking, ReactiveEffect, trackEffects, triggerEffects } from \"./effect\";\n\n\nclass ComputedRefImpl {\n    public dep; // this.dep = undefined;\n    public _dirty = true; // this._dirty = true;\n    public __v_isRef = true;\n    public effect; // 计算属性是依赖于effect的\n    public _value;\n    constructor(getter, public setter) { // 只有调用computed()才执行一次\n        // 这里将计算属性包成一个effect\n        // 这里 我给计算属性变成了effect ，那么计算属性中的属性会收集这个effect\n        this.effect = new ReactiveEffect(getter,()=>{\n            // 稍后计算属性依赖的值变化 不要重新执行计算属性的effect，而是调用此函数\n            if(!this._dirty){\n                this._dirty = true;\n                triggerEffects(this.dep )\n            }\n        });\n    }\n    get value() { // 取值时会走get方法\n        if (isTracking()) { // 是否是在effect中取值的\n            trackEffects(this.dep || (this.dep = new Set))\n        }\n        if (this._dirty) {\n            // 将结果缓存到this._value 这样就不用每次都run了\n            this._value = this.effect.run();\n            this._dirty = false;\n        }\n        return this._value;\n    }\n    set value(newValue) {\n        this.setter(newValue); // 如果修改计算属性的值 就触发你自己的set方法\n    }\n}\nexport function computed(getterOrOptions) {\n    const onlyGetter = isFunction(getterOrOptions);\n    let getter;\n    let setter;\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = () => { }\n    } else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n\n    return new ComputedRefImpl(getter, setter)\n}","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 16:43:46\n * @LastEditTime: 2021-12-18 16:48:58\n * @LastEditors: changqing\n * @Usage: \n */\nimport { isTracking, trackEffects, triggerEffects } from \"./effect\";\nimport { toReactive } from \"./reactive\";\n\nclass RefImpl{\n    public dep;\n    public __v_isRef;\n    public _value;\n    constructor(public _rawValue){ // 原来的值\n        // _rawValue如果用户传进来的值 是一个对象 我需要将对象转化成响应式\n        this._value = toReactive(_rawValue)\n    }\n\n  \n    // 类的属性访问器 最终会变成deifneProperty\n    get value(){ // 取值的时候进行依赖收集\n        if(isTracking()){\n            trackEffects(this.dep || (this.dep = new Set()));\n        }\n        return this._value;\n    }\n    set value(newValue){ // 设置的时候触发更新\n        if(newValue !== this._rawValue){\n            // 先看一下之前之后是否一样\n            this._rawValue = newValue;\n            this._value =  toReactive(newValue);\n            triggerEffects(this.dep);\n        }\n    }\n}\n\nfunction createRef(value){\n\n    return new RefImpl(value);\n}\n\n\nexport function ref(value){\n    return createRef(value);\n}\n\n// export function shallowRef(value){\n //   return createRef(value,true);\n// }\n\n// reactive readonly ","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 21:18:03\n * @LastEditTime: 2021-12-18 22:32:25\n * @LastEditors: changqing\n * @Usage: \n */\nimport { ShapeFlags } from '@vue/shared'\nimport { createAppAPI } from './apiCreateApp'\n\nexport * from '@vue/reactivity'\n\n\n// runtime-core  根平台无关的运行时  \n\n\n\nexport function createRenderer(renderOptions) { // runtime-core   renderOptionsDOMAPI -> rootComponent -> rootProps -> container\n    const mountComponent = (initialVNode,container) =>{ // 组件的挂载流程\n        // 根据组件的虚拟节点 创造一个真实节点 ， 渲染到容器中\n        //console.log(initialVNode,container)\n    }\n    const processComponent = (n1,n2,container) =>{\n        if(n1 == null){\n            // 组件的初始化\n            mountComponent(n2,container);\n        }else{\n            // 组件的更新\n        }\n    }\n    const patch = (n1, n2, container) => {\n        if(n1 == n2) return ;\n        const {shapeFlag} = n2; // createApp(组件)\n        if(shapeFlag & ShapeFlags.COMPONENT){\n            processComponent(n1, n2, container);\n        }\n\n    }   \n\n    const render = (vnode, container) => { // 将虚拟节点 转化成真实节点渲染到容器中\n        // 后续还有更新 patch  包含初次渲染 还包含更新\n        patch(null, vnode, container);// 后续更新 prevNode nextNode container\n    }\n    // \n    return {\n        createApp: createAppAPI(render), // 创建一个api createApp\n        render\n    }\n}","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 22:01:35\n * @LastEditTime: 2021-12-18 22:01:35\n * @LastEditors: changqing\n * @Usage: \n */\nexport const nodeOps = {\n  insert: (child, parent, anchor = null) => { // 插入有追加的功能\n      parent.insertBefore(child, anchor); // parent.appendChild(child)\n  },\n  remove: child => {\n      const parent = child.parentNode;\n      if (parent) {\n          parent.removeChild(child);\n      }\n  },\n  createElement: tag => document.createElement(tag),\n  createText: text => document.createTextNode(text),\n  setElementText: (el, text) => el.textContent = text,\n  setText: (node, text) => node.nodeValue = text,\n  parentNode: node => node.parentNode,\n  nextSibling: node => node.nextSibling,\n  querySelector: selector => document.querySelector(selector)\n}\n\n\n// runtime-dom 提供 节点操作的api -> 传递给 runtime-core ","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 22:02:11\n * @LastEditTime: 2021-12-18 22:03:19\n * @LastEditors: changqing\n * @Usage: \n */\n\n\n// 需要比对属性 diff算法    属性比对前后值\nfunction patchClass(el, value) {\n  if (value == null) {\n      el.removeAttribute('class');\n  } else {\n      el.className = value;\n  }\n}\nfunction patchStyle(el, prev, next) {\n  const style = el.style; // 操作的是样式\n  // 最新的肯定要全部加到元素上\n  for (let key in next) {\n      style[key] = next[key];\n  }\n  // 新的没有 但是老的有这个属性, 将老的移除掉\n  if (prev) {\n      for (let key in prev) {\n          if (next[key] == null) {\n              style[key] = null;\n          }\n      }\n  }\n}\nfunction createInvoker(value) {\n  const invoker = (e) => { // 每次事件触发调用的都是invoker \n      invoker.value(e)\n  }\n  invoker.value = value; // 存储这个变量, 后续想换绑 可以直接更新value值\n  return invoker\n}\nfunction patchEvent(el, key, nextValue) {\n  // vei  vue event invoker  缓存绑定的事件 \n  const invokers = el._vei || (el._vei = {}); // 在元素上绑定一个自定义属性 用来记录绑定的事件\n  let exisitingInvoker = invokers[key]; // 先看一下有没有绑定过这个事件\n  if (exisitingInvoker && nextValue) { // 换绑逻辑\n      exisitingInvoker.value = nextValue\n  } else {\n      const name = key.slice(2).toLowerCase(); // eventName\n      if (nextValue) {\n          const invoker = invokers[key] = createInvoker(nextValue); // 返回一个引用\n          el.addEventListener(name, invoker);  // 正规的时间 onClick =(e)=>{}\n      } else if (exisitingInvoker) {\n          // 如果下一个值没有 需要删除\n          el.removeEventListener(name, exisitingInvoker);\n          invokers[key] = undefined; // 解绑了\n      }\n      // else{\n      //     // 压根没有绑定过 事件就不需要删除了\n      // }\n  }\n}\nfunction patchAttr(el, key, value) {\n  if (value == null) {\n      el.removeAttribute(key)\n  } else {\n      el.setAttribute(key, value)\n  }\n}\nexport const patchProp = (el, key, prevValue, nextValue) => {\n  if (key === 'class') { // 类名 \n      patchClass(el, nextValue); // \n  } else if (key === 'style') { // 样式\n      patchStyle(el, prevValue, nextValue);\n  } else if (/^on[^a-z]/.test(key)) { // onXxx\n      // 如果有事件 addEventListener  如果没事件 应该用removeListener\n      patchEvent(el, key, nextValue);\n      // 绑定一个 换帮了一个  在换绑一个\n  } else {\n      // 其他属性 setAttribute\n      patchAttr(el, key, nextValue);\n  }\n}","/*\n * @Description: \n * @Author: changqing\n * @Date: 2021-12-18 21:19:59\n * @LastEditTime: 2021-12-18 22:07:29\n * @LastEditors: changqing\n * @Usage: \n */\n// 需要涵盖我们的 dom操作的api 属性操作的api  ， 将这些api 传入到 我们的runtime-core中\n// runtime-core 在操作中不需要依赖于平台代码 （平台代码是被传入的）\n// 我们在渲染页面的时候 需要节点操作的一系列方法\n\nimport { createRenderer } from '@vue/runtime-core';\nimport { nodeOps } from './nodeOps';\nimport { patchProp } from './patchProp';\n\nconst renderOptions = Object.assign(nodeOps, { patchProp }); // 包含所需要的所有api\n\n\n// 实现将renderOptions 传入到core中\n// runtime-dom  在这层 对我们浏览器的操作做了一些\nexport const createApp = (component, rootProps = null) => {\n    // 需要创建一个渲染器\n    const { createApp } = createRenderer(renderOptions); // runtime-core中的方法\n    let app = createApp(component, rootProps);\n    let { mount } = app; // 获取core中mount\n    app.mount = function (container) {  // 在重写mount\n        container = nodeOps.querySelector(container);\n        container.innerHTML = '';\n        mount(container); // 处理节点后传入到mount中\n    }\n    return app;\n}\n\nexport const createSSRApp = () =>{ \n\n}\n\nexport * from '@vue/runtime-core'; // 导出这个模块中的所有代码  es6 模块规范\n\n"],"names":[],"mappings":"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"}